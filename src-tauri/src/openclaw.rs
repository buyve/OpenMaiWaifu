//! OpenClaw integration — chat, webhook, and health check commands.
//!
//! Communication with the OpenClaw platform uses two channels:
//!
//! 1. **CLI subprocess** (`openclaw agent --agent <id> --message <msg>`) —
//!    used for interactive chat because it blocks until the agent replies.
//!    The gateway's `/hooks/agent` endpoint only returns HTTP 202 (async),
//!    so the CLI is the only way to get a synchronous response.
//!
//! 2. **HTTP POST** to `/hooks/agent` — used for fire-and-forget triggers
//!    (e.g. screen-watch observations) where we don't need the reply.
//!
//! Authentication uses a Bearer token generated by [`setup_openclaw_hooks`]
//! and shared between the app config and `~/.openclaw/openclaw.json`.

use crate::config::ConfigState;
use serde::{Deserialize, Serialize};
use std::process::Stdio;
use std::time::Duration;
use tauri::State;

/// Timeout for the `openclaw agent` CLI subprocess (2 minutes).
const CLI_TIMEOUT_SECS: u64 = 120;

/// Timeout for HTTP requests — health check and webhook (10 seconds).
const HTTP_TIMEOUT_SECS: u64 = 10;

// ---------- Shared HTTP Client ----------

/// A shared `reqwest::Client` registered as Tauri managed state.
///
/// Reusing a single client enables HTTP/2 connection pooling and avoids
/// per-request TLS handshake overhead.
pub struct HttpClient {
    inner: reqwest::Client,
}

impl HttpClient {
    /// Create a new HTTP client with default settings.
    ///
    /// # Panics
    ///
    /// Panics if the underlying `reqwest::Client::builder().build()` fails,
    /// which should only happen if TLS initialization fails.
    pub fn new() -> Self {
        Self {
            inner: reqwest::Client::builder()
                .build()
                .expect("Failed to create reqwest::Client"),
        }
    }
}

// ---------- Request/Response Types ----------

/// JSON payload sent to the OpenClaw Gateway `POST /hooks/agent` endpoint.
#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
struct HooksAgentRequest {
    message: String,
    agent_id: String,
    deliver: bool,
    #[serde(skip_serializing_if = "String::is_empty")]
    session_key: String,
}

/// Chat response returned to the frontend via the `send_chat` IPC command.
///
/// The frontend parses emotion/motion from the response text
/// via `emotionParser.parseResponse()`.
#[derive(Deserialize, Serialize, Clone)]
pub struct ChatResponse {
    pub response: String,
}

// ---------- Commands ----------

/// Send a chat message via the `openclaw agent` CLI subprocess.
///
/// Spawns the CLI as a blocking subprocess (via `tokio::task::spawn_blocking`)
/// and waits for it to produce a response. The gateway's `/hooks/agent`
/// endpoint only returns HTTP 202 (async), so for interactive chat we shell
/// out to the CLI which waits for the full agent reply.
///
/// # Environment setup
///
/// The subprocess is configured with:
/// - `stdin` closed (`Stdio::null()`) to prevent hanging on interactive prompts
/// - `NO_COLOR=1`, `TERM=dumb`, `FORCE_COLOR=0` to suppress ANSI escape codes
/// - `PATH` augmented with common binary locations (`~/.npm-global/bin`,
///   `~/.local/bin`, `~/.bun/bin`, `/usr/local/bin`, `/opt/homebrew/bin`)
///   because Tauri apps on macOS don't inherit the user's shell PATH
///
/// # Errors
///
/// Returns `Err` if the agent ID is not configured, the CLI binary is not
/// found, the subprocess exits with a non-zero status, or stdout is empty.
#[tauri::command]
pub async fn send_chat(
    config_state: State<'_, ConfigState>,
    message: String,
    context: Option<String>,
) -> Result<ChatResponse, String> {
    let config = config_state.get()?;

    if config.agent_id.is_empty() {
        return Err(
            "Agent ID not configured. Open Settings to configure OpenClaw connection.".to_string(),
        );
    }

    let full_message = match context {
        Some(ctx) if !ctx.is_empty() => format!("{}\n\n[USER MESSAGE]\n{}", ctx, message),
        _ => message,
    };

    let cli = if config.cli_path.is_empty() {
        "openclaw"
    } else {
        &config.cli_path
    };

    let cli_owned = cli.to_string();
    let agent_id = config.agent_id.clone();
    let session_key = config.session_key.clone();

    eprintln!(
        "[send_chat] Running: {} agent --agent {} --message <{} chars>",
        cli_owned,
        &agent_id,
        full_message.len(),
    );

    let timeout = Duration::from_secs(CLI_TIMEOUT_SECS);

    // Share the child process so we can kill it on timeout.
    // Uses Arc<Mutex<Option<Child>>> — the blocking thread holds a &mut ref
    // while reading output; on timeout the main task calls kill().
    let child_handle: std::sync::Arc<std::sync::Mutex<Option<std::process::Child>>> =
        std::sync::Arc::new(std::sync::Mutex::new(None));
    let child_for_timeout = child_handle.clone();

    let output = tokio::time::timeout(timeout, tokio::task::spawn_blocking(move || -> std::io::Result<std::process::Output> {
        let mut cmd = std::process::Command::new(&cli_owned);
        cmd.arg("agent")
            .arg("--agent")
            .arg(&agent_id)
            .arg("--message")
            .arg(&full_message);

        if !session_key.is_empty() {
            cmd.arg("--session-id").arg(&session_key);
        }

        cmd.stdin(Stdio::null());
        cmd.stdout(Stdio::piped());
        cmd.stderr(Stdio::piped());

        cmd.env("NO_COLOR", "1");
        cmd.env("TERM", "dumb");
        cmd.env("FORCE_COLOR", "0");

        if let Ok(home) = std::env::var("HOME") {
            let extra_paths = [
                format!("{home}/.npm-global/bin"),
                format!("{home}/.local/bin"),
                format!("{home}/.bun/bin"),
                "/usr/local/bin".to_string(),
                "/opt/homebrew/bin".to_string(),
            ];
            let current_path = std::env::var("PATH").unwrap_or_default();
            let new_path = format!("{}:{}", extra_paths.join(":"), current_path);
            cmd.env("PATH", new_path);
            cmd.env("HOME", home);
        }

        let mut child = cmd.spawn()?;

        // Take piped stdout/stderr before storing child in the shared handle
        let stdout_pipe = child.stdout.take();
        let stderr_pipe = child.stderr.take();

        // Store child in shared handle so the timeout path can kill it
        *child_handle.lock().map_err(|e| {
            std::io::Error::new(std::io::ErrorKind::Other, format!("Mutex poisoned on store: {e}"))
        })? = Some(child);

        // Read stdout and stderr
        use std::io::Read;
        let mut stdout_buf = Vec::new();
        let mut stderr_buf = Vec::new();
        if let Some(mut out) = stdout_pipe {
            let _ = out.read_to_end(&mut stdout_buf);
        }
        if let Some(mut err) = stderr_pipe {
            let _ = err.read_to_end(&mut stderr_buf);
        }

        // Wait for the child to exit
        let status = child_handle
            .lock()
            .map_err(|e| {
                std::io::Error::new(std::io::ErrorKind::Other, format!("Mutex poisoned on wait: {e}"))
            })?
            .as_mut()
            .ok_or_else(|| {
                std::io::Error::new(std::io::ErrorKind::Other, "Child process handle missing")
            })?
            .wait()?;

        Ok(std::process::Output { status, stdout: stdout_buf, stderr: stderr_buf })
    }))
    .await;

    // Handle timeout: kill the subprocess if it's still running
    let output: std::process::Output = match output {
        Ok(join_result) => {
            join_result
                .map_err(|e| format!("Task join error: {e}"))?
                .map_err(|e| {
                    format!("Failed to run openclaw CLI: {e}. Is openclaw installed and in PATH?")
                })?
        }
        Err(_) => {
            // Timeout — kill the child process to prevent orphaning
            if let Ok(mut guard) = child_for_timeout.lock() {
                if let Some(ref mut child) = *guard {
                    eprintln!("[send_chat] CLI timed out after {CLI_TIMEOUT_SECS}s — killing child process");
                    let _ = child.kill();
                    let _ = child.wait(); // Reap the zombie
                }
            }
            return Err(format!("openclaw CLI timed out after {CLI_TIMEOUT_SECS}s"));
        }
    };

    let stderr_text = String::from_utf8_lossy(&output.stderr).trim().to_string();
    if !stderr_text.is_empty() {
        eprintln!("[send_chat] stderr: {}", stderr_text);
    }

    if !output.status.success() {
        let msg = if stderr_text.is_empty() {
            format!("openclaw CLI exited with status {}", output.status)
        } else {
            format!("openclaw CLI error: {stderr_text}")
        };
        eprintln!("[send_chat] FAILED: {}", msg);
        return Err(msg);
    }

    let stdout = String::from_utf8_lossy(&output.stdout).trim().to_string();
    let preview_end = {
        let max = stdout.len().min(200);
        let mut end = max;
        while end > 0 && !stdout.is_char_boundary(end) {
            end -= 1;
        }
        end
    };
    eprintln!("[send_chat] stdout ({} chars): {}", stdout.len(), &stdout[..preview_end]);

    if stdout.is_empty() {
        return Err("OpenClaw returned an empty response".to_string());
    }

    Ok(ChatResponse {
        response: stdout,
    })
}

/// Fire-and-forget: send a message to the OpenClaw Gateway via POST /hooks/agent.
///
/// Returns immediately after the gateway accepts the request (HTTP 202).
/// Use this for background triggers where you don't need the agent's response.
#[tauri::command]
pub async fn send_webhook(
    http: State<'_, HttpClient>,
    config_state: State<'_, ConfigState>,
    message: String,
) -> Result<(), String> {
    let config = config_state.get()?;

    if config.agent_id.is_empty() {
        return Err(
            "Agent ID not configured. Open Settings to configure OpenClaw connection.".to_string(),
        );
    }

    let base = config.gateway_url.trim_end_matches('/');
    let url = format!("{}/hooks/agent", base);

    let body = HooksAgentRequest {
        message,
        agent_id: config.agent_id.clone(),
        deliver: false,
        session_key: config.session_key.clone(),
    };

    let mut request = http
        .inner
        .post(&url)
        .timeout(Duration::from_secs(HTTP_TIMEOUT_SECS))
        .json(&body);

    if !config.hooks_token.is_empty() {
        request = request.bearer_auth(&config.hooks_token);
    }

    let response = request.send().await.map_err(|e| {
        if e.is_timeout() {
            "Webhook request timed out".to_string()
        } else if e.is_connect() {
            "Cannot connect to OpenClaw Gateway. Check gateway URL in Settings.".to_string()
        } else {
            format!("Webhook request failed: {e}")
        }
    })?;

    let status = response.status().as_u16();
    if status == 200 || status == 202 {
        Ok(())
    } else {
        let body_text = response.text().await.unwrap_or_default();
        let preview = if body_text.len() > 200 {
            let mut end = 200;
            while end > 0 && !body_text.is_char_boundary(end) {
                end -= 1;
            }
            format!("{}...", &body_text[..end])
        } else {
            body_text
        };
        Err(format!("OpenClaw returned status {status}: {preview}"))
    }
}

/// Check if the OpenClaw Gateway is reachable.
///
/// Sends a GET to the gateway base URL. Any HTTP response (even 404)
/// means the server is running; only connection errors count as offline.
#[tauri::command]
pub async fn check_openclaw_health(
    http: State<'_, HttpClient>,
    config_state: State<'_, ConfigState>,
) -> Result<bool, String> {
    let config = config_state.get()?;
    let base = config.gateway_url.trim_end_matches('/');

    match http
        .inner
        .get(base)
        .timeout(Duration::from_secs(HTTP_TIMEOUT_SECS))
        .send()
        .await
    {
        Ok(_) => Ok(true),
        Err(_) => Ok(false),
    }
}

/// Configure OpenClaw hooks in ~/.openclaw/openclaw.json.
///
/// Reads the existing config (if any), sets `hooks.enabled = true` with a
/// freshly generated token, writes it back, and also saves the token into
/// the app's own config so the webhook auth is automatically set up.
///
/// Returns the generated token string.
#[tauri::command]
pub async fn setup_openclaw_hooks(
    config_state: State<'_, ConfigState>,
) -> Result<String, String> {
    let openclaw_dir = dirs::home_dir()
        .ok_or("Cannot determine home directory")?
        .join(".openclaw");

    std::fs::create_dir_all(&openclaw_dir)
        .map_err(|e| format!("Failed to create ~/.openclaw: {e}"))?;

    let config_path = openclaw_dir.join("openclaw.json");

    // Read existing config or start with empty object
    let mut json: serde_json::Value = if config_path.exists() {
        let content = std::fs::read_to_string(&config_path)
            .map_err(|e| format!("Failed to read openclaw.json: {e}"))?;
        serde_json::from_str(&content).unwrap_or(serde_json::json!({}))
    } else {
        serde_json::json!({})
    };

    // Generate a random token
    let token = generate_token()?;

    // Set hooks config
    json["hooks"] = serde_json::json!({
        "enabled": true,
        "token": token,
    });

    // Write back
    let pretty = serde_json::to_string_pretty(&json)
        .map_err(|e| format!("Failed to serialize config: {e}"))?;
    std::fs::write(&config_path, pretty)
        .map_err(|e| format!("Failed to write openclaw.json: {e}"))?;

    // Also save the token to our app config
    {
        let mut app_config = config_state.config.write().map_err(|e| e.to_string())?;
        app_config.hooks_token = token.clone();
    }
    config_state.save()?;

    Ok(token)
}

// ---------- Setup Wizard Commands ----------

/// Result of checking whether the OpenClaw CLI is installed.
#[derive(Serialize)]
pub struct InstalledCheck {
    pub installed: bool,
    pub version: String,
}

/// Basic agent info returned by `openclaw agents list --json`.
#[derive(Deserialize, Serialize, Clone)]
pub struct AgentInfo {
    pub id: String,
    pub name: String,
}

/// Build a `std::process::Command` pre-configured with PATH augmentation
/// and environment variables suitable for running `openclaw` subprocesses
/// from inside the Tauri app (which doesn't inherit the user's shell PATH).
fn build_openclaw_cmd(cli: &str) -> std::process::Command {
    let mut cmd = std::process::Command::new(cli);
    cmd.stdin(Stdio::null());
    cmd.stdout(Stdio::piped());
    cmd.stderr(Stdio::piped());
    cmd.env("NO_COLOR", "1");
    cmd.env("TERM", "dumb");
    cmd.env("FORCE_COLOR", "0");

    if let Ok(home) = std::env::var("HOME") {
        let extra_paths = [
            format!("{home}/.npm-global/bin"),
            format!("{home}/.local/bin"),
            format!("{home}/.bun/bin"),
            "/usr/local/bin".to_string(),
            "/opt/homebrew/bin".to_string(),
        ];
        let current_path = std::env::var("PATH").unwrap_or_default();
        let new_path = format!("{}:{}", extra_paths.join(":"), current_path);
        cmd.env("PATH", new_path);
        cmd.env("HOME", home);
    }

    cmd
}

/// Check whether the OpenClaw CLI is installed by running `openclaw --version`.
///
/// Returns `{ installed: true, version: "..." }` on success,
/// or `{ installed: false, version: "" }` if the binary cannot be found
/// or the command times out (5 seconds).
#[tauri::command]
pub async fn check_openclaw_installed(
    config_state: State<'_, ConfigState>,
) -> Result<InstalledCheck, String> {
    let config = config_state.get()?;
    let cli = if config.cli_path.is_empty() {
        "openclaw".to_string()
    } else {
        config.cli_path.clone()
    };

    let result = tokio::time::timeout(
        Duration::from_secs(5),
        tokio::task::spawn_blocking(move || -> std::io::Result<std::process::Output> {
            let mut cmd = build_openclaw_cmd(&cli);
            cmd.arg("--version");
            cmd.output()
        }),
    )
    .await;

    match result {
        Ok(Ok(Ok(output))) if output.status.success() => {
            let version = String::from_utf8_lossy(&output.stdout).trim().to_string();
            Ok(InstalledCheck {
                installed: true,
                version,
            })
        }
        _ => Ok(InstalledCheck {
            installed: false,
            version: String::new(),
        }),
    }
}

/// List existing OpenClaw agents by running `openclaw agents list --json`.
///
/// Parses the JSON output into a `Vec<AgentInfo>`. Returns an empty vector
/// if the command fails or produces no agents.
#[tauri::command]
pub async fn list_openclaw_agents(
    config_state: State<'_, ConfigState>,
) -> Result<Vec<AgentInfo>, String> {
    let config = config_state.get()?;
    let cli = if config.cli_path.is_empty() {
        "openclaw".to_string()
    } else {
        config.cli_path.clone()
    };

    let result = tokio::time::timeout(
        Duration::from_secs(10),
        tokio::task::spawn_blocking(move || -> std::io::Result<std::process::Output> {
            let mut cmd = build_openclaw_cmd(&cli);
            cmd.arg("agents").arg("list").arg("--json");
            cmd.output()
        }),
    )
    .await;

    match result {
        Ok(Ok(Ok(output))) if output.status.success() => {
            let stdout = String::from_utf8_lossy(&output.stdout).trim().to_string();
            // Try parsing as array of AgentInfo
            let agents: Vec<AgentInfo> = serde_json::from_str(&stdout).unwrap_or_default();
            Ok(agents)
        }
        Ok(Ok(Ok(output))) => {
            let stderr = String::from_utf8_lossy(&output.stderr).trim().to_string();
            eprintln!("[list_openclaw_agents] CLI failed: {stderr}");
            Ok(vec![])
        }
        _ => Ok(vec![]),
    }
}

/// Create a new OpenClaw agent by running `openclaw agents add <name> --non-interactive`.
///
/// Returns the agent name on success.
#[tauri::command]
pub async fn create_openclaw_agent(
    config_state: State<'_, ConfigState>,
    name: String,
) -> Result<String, String> {
    let config = config_state.get()?;
    let cli = if config.cli_path.is_empty() {
        "openclaw".to_string()
    } else {
        config.cli_path.clone()
    };

    let agent_name = name.clone();

    let result = tokio::time::timeout(
        Duration::from_secs(30),
        tokio::task::spawn_blocking(move || -> std::io::Result<std::process::Output> {
            let mut cmd = build_openclaw_cmd(&cli);
            cmd.arg("agents").arg("add").arg(&agent_name).arg("--non-interactive");
            cmd.output()
        }),
    )
    .await;

    match result {
        Ok(Ok(Ok(output))) if output.status.success() => Ok(name),
        Ok(Ok(Ok(output))) => {
            let stderr = String::from_utf8_lossy(&output.stderr).trim().to_string();
            Err(format!("Failed to create agent: {stderr}"))
        }
        Ok(Ok(Err(e))) => Err(format!("Failed to run openclaw CLI: {e}")),
        Ok(Err(e)) => Err(format!("Task join error: {e}")),
        Err(_) => Err("Agent creation timed out after 30s".to_string()),
    }
}

/// Generate a 64-character random hex token using cryptographic randomness.
///
/// This is used as the Bearer token for OpenClaw webhook authentication.
/// The token is written to both the app config and `~/.openclaw/openclaw.json`.
fn generate_token() -> Result<String, String> {
    let mut buf = [0u8; 32];
    getrandom::getrandom(&mut buf)
        .map_err(|e| format!("Failed to generate random token: {}", e))?;
    Ok(buf.iter().map(|b| format!("{:02x}", b)).collect())
}
